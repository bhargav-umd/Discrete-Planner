<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Motion Planning: Discrete Planners: optimalPlanner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motion Planning: Discrete Planners
   </div>
   <div id="projectbrief">Toextendalibraryofdiscretemotionplannersforanholonomicrobot.Therobot</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoptimalPlanner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">optimalPlanner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Optimal Planner class members declaration we are using Astar algorithm for finding optimal path.  
 <a href="classoptimalPlanner.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="optimalPlanner_8h_source.html">optimalPlanner.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7e8d3560aee12ecf15c0b12e44a657d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a7e8d3560aee12ecf15c0b12e44a657d1">optimalPlanner</a> ()</td></tr>
<tr class="memdesc:a7e8d3560aee12ecf15c0b12e44a657d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor for the class.  <a href="#a7e8d3560aee12ecf15c0b12e44a657d1">More...</a><br /></td></tr>
<tr class="separator:a7e8d3560aee12ecf15c0b12e44a657d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00822a341c20c01a0f13cf71700023ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a00822a341c20c01a0f13cf71700023ae">optimalPlanner</a> (std::vector&lt; std::vector&lt; int &gt;&gt;, std::pair&lt; int, int &gt;, std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a00822a341c20c01a0f13cf71700023ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterised Constructor with given inputs.  <a href="#a00822a341c20c01a0f13cf71700023ae">More...</a><br /></td></tr>
<tr class="separator:a00822a341c20c01a0f13cf71700023ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234f4f638c9fa4fb3eb539a4c5f715a5"><td class="memItemLeft" align="right" valign="top">std::stack&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a234f4f638c9fa4fb3eb539a4c5f715a5">search</a> (std::vector&lt; std::vector&lt; int &gt;&gt;, std::pair&lt; int, int &gt;, std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a234f4f638c9fa4fb3eb539a4c5f715a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the path using astar algorithm.  <a href="#a234f4f638c9fa4fb3eb539a4c5f715a5">More...</a><br /></td></tr>
<tr class="separator:a234f4f638c9fa4fb3eb539a4c5f715a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb26d5b89c5a4cd5caec0ada6bd1921b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#afb26d5b89c5a4cd5caec0ada6bd1921b">getStartingPoint</a> ()</td></tr>
<tr class="memdesc:afb26d5b89c5a4cd5caec0ada6bd1921b"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter function to get start location of robot  <a href="#afb26d5b89c5a4cd5caec0ada6bd1921b">More...</a><br /></td></tr>
<tr class="separator:afb26d5b89c5a4cd5caec0ada6bd1921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd6489e659be67503f007183cd8be05"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a2cd6489e659be67503f007183cd8be05">getGoalPoint</a> ()</td></tr>
<tr class="memdesc:a2cd6489e659be67503f007183cd8be05"><td class="mdescLeft">&#160;</td><td class="mdescRight">gettter function for Goal Point  <a href="#a2cd6489e659be67503f007183cd8be05">More...</a><br /></td></tr>
<tr class="separator:a2cd6489e659be67503f007183cd8be05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35486c87400cea9e455ef73246844a47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a35486c87400cea9e455ef73246844a47">getXLength</a> ()</td></tr>
<tr class="memdesc:a35486c87400cea9e455ef73246844a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter fucntion for X length  <a href="#a35486c87400cea9e455ef73246844a47">More...</a><br /></td></tr>
<tr class="separator:a35486c87400cea9e455ef73246844a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7297bd9b3a207aedc7b8dd260b5270"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#afc7297bd9b3a207aedc7b8dd260b5270">getYLength</a> ()</td></tr>
<tr class="memdesc:afc7297bd9b3a207aedc7b8dd260b5270"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter function for Y Length  <a href="#afc7297bd9b3a207aedc7b8dd260b5270">More...</a><br /></td></tr>
<tr class="separator:afc7297bd9b3a207aedc7b8dd260b5270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38869628f0c69e3a224de8730ca70bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnode.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a38869628f0c69e3a224de8730ca70bce">getNodeInformation</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a38869628f0c69e3a224de8730ca70bce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a> INformation stores all nodes at respective locations.  <a href="#a38869628f0c69e3a224de8730ca70bce">More...</a><br /></td></tr>
<tr class="separator:a38869628f0c69e3a224de8730ca70bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4a2dcda06b4f230aae5fcd056270d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a0b4a2dcda06b4f230aae5fcd056270d8">isValid</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a0b4a2dcda06b4f230aae5fcd056270d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">To check if the given valid by checking boundaries.  <a href="#a0b4a2dcda06b4f230aae5fcd056270d8">More...</a><br /></td></tr>
<tr class="separator:a0b4a2dcda06b4f230aae5fcd056270d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd923e57309f44ce1734b652b40103c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#affd923e57309f44ce1734b652b40103c">isBlocked</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:affd923e57309f44ce1734b652b40103c"><td class="mdescLeft">&#160;</td><td class="mdescRight">to check if the location has obstacle or not  <a href="#affd923e57309f44ce1734b652b40103c">More...</a><br /></td></tr>
<tr class="separator:affd923e57309f44ce1734b652b40103c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e96d238d9d57f486453816d221df25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#aa8e96d238d9d57f486453816d221df25">isItGoalYet</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:aa8e96d238d9d57f486453816d221df25"><td class="mdescLeft">&#160;</td><td class="mdescRight">To check if the location is goal or not.  <a href="#aa8e96d238d9d57f486453816d221df25">More...</a><br /></td></tr>
<tr class="separator:aa8e96d238d9d57f486453816d221df25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca65cc3a34ea39614c0da1fb4ab1189"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a2ca65cc3a34ea39614c0da1fb4ab1189">calculateHCost</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a2ca65cc3a34ea39614c0da1fb4ab1189"><td class="mdescLeft">&#160;</td><td class="mdescRight">To calculate H Cost, i.e, cost to reach the goal.  <a href="#a2ca65cc3a34ea39614c0da1fb4ab1189">More...</a><br /></td></tr>
<tr class="separator:a2ca65cc3a34ea39614c0da1fb4ab1189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6892e6beceed5ca588d1bf46b7d40b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a9a6892e6beceed5ca588d1bf46b7d40b">trackPath</a> ()</td></tr>
<tr class="memdesc:a9a6892e6beceed5ca588d1bf46b7d40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">To track the path by tracking individual parents.  <a href="#a9a6892e6beceed5ca588d1bf46b7d40b">More...</a><br /></td></tr>
<tr class="separator:a9a6892e6beceed5ca588d1bf46b7d40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f886dd1ad67dd6a8f0d747c316830e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a5f886dd1ad67dd6a8f0d747c316830e2">moveAndUpdateNodes</a> (std::pair&lt; int, int &gt;, std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a5f886dd1ad67dd6a8f0d747c316830e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update node informations as we explore the map with all costs.  <a href="#a5f886dd1ad67dd6a8f0d747c316830e2">More...</a><br /></td></tr>
<tr class="separator:a5f886dd1ad67dd6a8f0d747c316830e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a4e25f991be60cacc9dd74af0a41b8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a99a4e25f991be60cacc9dd74af0a41b8">goTop</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a99a4e25f991be60cacc9dd74af0a41b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">To move in respective location.  <a href="#a99a4e25f991be60cacc9dd74af0a41b8">More...</a><br /></td></tr>
<tr class="separator:a99a4e25f991be60cacc9dd74af0a41b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae846f7b527b1aeedada33c12bf620ccb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#ae846f7b527b1aeedada33c12bf620ccb">goLeft</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:ae846f7b527b1aeedada33c12bf620ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">To move in respective location.  <a href="#ae846f7b527b1aeedada33c12bf620ccb">More...</a><br /></td></tr>
<tr class="separator:ae846f7b527b1aeedada33c12bf620ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921f457476a499fabdc4796057b7b47f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#a921f457476a499fabdc4796057b7b47f">goBottom</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a921f457476a499fabdc4796057b7b47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">To move in respective location.  <a href="#a921f457476a499fabdc4796057b7b47f">More...</a><br /></td></tr>
<tr class="separator:a921f457476a499fabdc4796057b7b47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d87157d27807b2276c2e4a7536c12e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimalPlanner.html#af1d87157d27807b2276c2e4a7536c12e">goRight</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:af1d87157d27807b2276c2e4a7536c12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">To move in respective location.  <a href="#af1d87157d27807b2276c2e4a7536c12e">More...</a><br /></td></tr>
<tr class="separator:af1d87157d27807b2276c2e4a7536c12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Optimal Planner class members declaration we are using Astar algorithm for finding optimal path. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7e8d3560aee12ecf15c0b12e44a657d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">optimalPlanner::optimalPlanner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default Constructor for the class. </p>
<p>Default Planner for optimal planner class. </p>

</div>
</div>
<a class="anchor" id="a00822a341c20c01a0f13cf71700023ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">optimalPlanner::optimalPlanner </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt;&#160;</td>
          <td class="paramname"><em>world_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>robot_pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>goal_pose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameterised Constructor with given inputs. </p>
<p>Parameterised Constructor for the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::vector&lt;std::vector&lt;int&gt;&gt;</td><td>world map </td></tr>
    <tr><td class="paramname">std::pair</td><td>robot start location </td></tr>
    <tr><td class="paramname">std::pair</td><td>robot goal location</td></tr>
    <tr><td class="paramname">world_map</td><td></td></tr>
    <tr><td class="paramname">robot_pose</td><td></td></tr>
    <tr><td class="paramname">goal_pose</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2ca65cc3a34ea39614c0da1fb4ab1189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double optimalPlanner::calculateHCost </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To calculate H Cost, i.e, cost to reach the goal. </p>
<p>Using Manhattan DIstance to calculate H cost for the location in map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair&lt;int,int&gt;</td><td>location coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>H cost of the location .</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double , Hcost value </dd></dl>

</div>
</div>
<a class="anchor" id="a2cd6489e659be67503f007183cd8be05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; optimalPlanner::getGoalPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gettter function for Goal Point </p>
<dl class="section return"><dt>Returns</dt><dd>destination of the robot </dd></dl>

</div>
</div>
<a class="anchor" id="a38869628f0c69e3a224de8730ca70bce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnode.html">node</a> optimalPlanner::getNodeInformation </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a> INformation stores all nodes at respective locations. </p>
<p>NodeInformation stores all nodes informatin , locaiton and all costs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair&lt;int,int&gt;</td><td>node information needed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node at respective location</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>find node at that location and return it as output </dd></dl>

</div>
</div>
<a class="anchor" id="afb26d5b89c5a4cd5caec0ada6bd1921b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; optimalPlanner::getStartingPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter function to get start location of robot </p>
<dl class="section return"><dt>Returns</dt><dd>robot starting location </dd></dl>

</div>
</div>
<a class="anchor" id="a35486c87400cea9e455ef73246844a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int optimalPlanner::getXLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter fucntion for X length </p>
<dl class="section return"><dt>Returns</dt><dd>x-length of the world map </dd></dl>

</div>
</div>
<a class="anchor" id="afc7297bd9b3a207aedc7b8dd260b5270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int optimalPlanner::getYLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter function for Y Length </p>
<dl class="section return"><dt>Returns</dt><dd>depth of the world map </dd></dl>

</div>
</div>
<a class="anchor" id="a921f457476a499fabdc4796057b7b47f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; optimalPlanner::goBottom </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To move in respective location. </p>
<p>To move in respective direction to produce more children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair</td><td>location to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new location</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new location of the child if robot moves </dd></dl>

</div>
</div>
<a class="anchor" id="ae846f7b527b1aeedada33c12bf620ccb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; optimalPlanner::goLeft </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To move in respective location. </p>
<p>To move in respective direction to produce more children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair</td><td>location to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new location</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new location of the child if robot moves </dd></dl>

</div>
</div>
<a class="anchor" id="af1d87157d27807b2276c2e4a7536c12e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; optimalPlanner::goRight </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To move in respective location. </p>
<p>To move in respective direction to produce more children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair</td><td>location to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new location</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new location of the child if robot moves </dd></dl>

</div>
</div>
<a class="anchor" id="a99a4e25f991be60cacc9dd74af0a41b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; optimalPlanner::goTop </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To move in respective location. </p>
<p>To move in respective direction to produce more children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair</td><td>location to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new location</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new location of the child if robot moves </dd></dl>

</div>
</div>
<a class="anchor" id="affd923e57309f44ce1734b652b40103c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool optimalPlanner::isBlocked </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>to check if the location has obstacle or not </p>
<p>To check if there is obstacle or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair&lt;int,int&gt;</td><td>location coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it has value of 1(obstacle ),else false</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if obstacle ,false if not obstacle </dd></dl>

</div>
</div>
<a class="anchor" id="aa8e96d238d9d57f486453816d221df25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool optimalPlanner::isItGoalYet </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To check if the location is goal or not. </p>
<p>Check for goal position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair&lt;int,int&gt;</td><td>location (y,x) coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its same as goal</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a0b4a2dcda06b4f230aae5fcd056270d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool optimalPlanner::isValid </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To check if the given valid by checking boundaries. </p>
<p>To check Validity by checking if its located in map or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair&lt;int,int&gt;</td><td>location whose validity needs to checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if not valid , else true</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if not located inside map else true </dd></dl>

</div>
</div>
<a class="anchor" id="a5f886dd1ad67dd6a8f0d747c316830e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void optimalPlanner::moveAndUpdateNodes </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update node informations as we explore the map with all costs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair</td><td>child node location </td></tr>
    <tr><td class="paramname">std::pair</td><td>parent node location</td></tr>
    <tr><td class="paramname">child</td><td></td></tr>
    <tr><td class="paramname">parent</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a234f4f638c9fa4fb3eb539a4c5f715a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt; std::pair&lt; int, int &gt; &gt; optimalPlanner::search </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt;&#160;</td>
          <td class="paramname"><em>world_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>robot_pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>goal_pose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the path using astar algorithm. </p>
<p>TO search using Astar Algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::vector&lt;std::vector&lt;int,int&gt;&gt;</td><td>world map </td></tr>
    <tr><td class="paramname">std::pair</td><td>robot start location </td></tr>
    <tr><td class="paramname">std::pair</td><td>robot goal location</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stack containing path positions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world_map</td><td></td></tr>
    <tr><td class="paramname">robot_pose</td><td></td></tr>
    <tr><td class="paramname">goal_pose</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Path </dd></dl>

</div>
</div>
<a class="anchor" id="a9a6892e6beceed5ca588d1bf46b7d40b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void optimalPlanner::trackPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To track the path by tracking individual parents. </p>
<p>Find Path based on parents of each node backwards. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/bob/Bob_old/Brain/Discrete_Planners/include/<a class="el" href="optimalPlanner_8h_source.html">optimalPlanner.h</a></li>
<li>/home/bob/Bob_old/Brain/Discrete_Planners/app/<a class="el" href="optimalPlanner_8cpp.html">optimalPlanner.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
