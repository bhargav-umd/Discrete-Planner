<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Motion Planning: Discrete Planners: RandomPlanner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motion Planning: Discrete Planners
   </div>
   <div id="projectbrief">Toextendalibraryofdiscretemotionplannersforanholonomicrobot.Therobot</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRandomPlanner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RandomPlanner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The random planner tries to find a path to the goal by randomly moving in the environment (only orthogonal moves are legal). If the planner can not find an acceptable solution in less than max_step_number, the search should fail. The random planner, while being erratic, has a short memory, and it will never attempt to visit a cell that was visited in the last sqrt(max_step_number) steps except if this is the only available option.  
 <a href="classRandomPlanner.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RandomPlanner_8h_source.html">RandomPlanner.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9eb31cb3b21cd5e50fde093f7a25a768"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9eb31cb3b21cd5e50fde093f7a25a768"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a9eb31cb3b21cd5e50fde093f7a25a768">RandomPlanner</a> ()</td></tr>
<tr class="memdesc:a9eb31cb3b21cd5e50fde093f7a25a768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. <br /></td></tr>
<tr class="separator:a9eb31cb3b21cd5e50fde093f7a25a768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927c717d77534e0db8ee2401b8e8b0ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a927c717d77534e0db8ee2401b8e8b0ed">RandomPlanner</a> (std::vector&lt; std::vector&lt; int &gt;&gt;, std::pair&lt; int, int &gt;, std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a927c717d77534e0db8ee2401b8e8b0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterised constructor to take map, starting position and goal position of robot.  <a href="#a927c717d77534e0db8ee2401b8e8b0ed">More...</a><br /></td></tr>
<tr class="separator:a927c717d77534e0db8ee2401b8e8b0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc4c7235eea43f4c7ff7c1c55b81511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNode.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a9bc4c7235eea43f4c7ff7c1c55b81511">moveUp</a> (<a class="el" href="structNode.html">Node</a>)</td></tr>
<tr class="memdesc:a9bc4c7235eea43f4c7ff7c1c55b81511"><td class="mdescLeft">&#160;</td><td class="mdescRight">to Move in up direction, updates current node  <a href="#a9bc4c7235eea43f4c7ff7c1c55b81511">More...</a><br /></td></tr>
<tr class="separator:a9bc4c7235eea43f4c7ff7c1c55b81511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37871c2c07e26640fb0619db0299a3ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNode.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a37871c2c07e26640fb0619db0299a3ba">moveLeft</a> (<a class="el" href="structNode.html">Node</a>)</td></tr>
<tr class="memdesc:a37871c2c07e26640fb0619db0299a3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">TO move in left location.  <a href="#a37871c2c07e26640fb0619db0299a3ba">More...</a><br /></td></tr>
<tr class="separator:a37871c2c07e26640fb0619db0299a3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac0a6fdc7dd5c2c2576ace8f26d87f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNode.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a6ac0a6fdc7dd5c2c2576ace8f26d87f5">moveDown</a> (<a class="el" href="structNode.html">Node</a>)</td></tr>
<tr class="memdesc:a6ac0a6fdc7dd5c2c2576ace8f26d87f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">TO move in +y direction.  <a href="#a6ac0a6fdc7dd5c2c2576ace8f26d87f5">More...</a><br /></td></tr>
<tr class="separator:a6ac0a6fdc7dd5c2c2576ace8f26d87f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b9b922d2d1b774dac4017024eda536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNode.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#af2b9b922d2d1b774dac4017024eda536">moveRight</a> (<a class="el" href="structNode.html">Node</a>)</td></tr>
<tr class="memdesc:af2b9b922d2d1b774dac4017024eda536"><td class="mdescLeft">&#160;</td><td class="mdescRight">to move in +x direction  <a href="#af2b9b922d2d1b774dac4017024eda536">More...</a><br /></td></tr>
<tr class="separator:af2b9b922d2d1b774dac4017024eda536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a1d04d84a1060fa760a2546788827e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1a1d04d84a1060fa760a2546788827e"></a>
std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#af1a1d04d84a1060fa760a2546788827e">getGoal</a> ()</td></tr>
<tr class="memdesc:af1a1d04d84a1060fa760a2546788827e"><td class="mdescLeft">&#160;</td><td class="mdescRight">to fetch goal location <br /></td></tr>
<tr class="separator:af1a1d04d84a1060fa760a2546788827e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb252bb39766353533c389f7392a6fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fb252bb39766353533c389f7392a6fd"></a>
std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a0fb252bb39766353533c389f7392a6fd">getStart</a> ()</td></tr>
<tr class="memdesc:a0fb252bb39766353533c389f7392a6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">to get starting location of the robot <br /></td></tr>
<tr class="separator:a0fb252bb39766353533c389f7392a6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2311066614013953f01b0658652e6b5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a2311066614013953f01b0658652e6b5e">isObstacle</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a2311066614013953f01b0658652e6b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">To check if robot is in defined boundary.  <a href="#a2311066614013953f01b0658652e6b5e">More...</a><br /></td></tr>
<tr class="separator:a2311066614013953f01b0658652e6b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0ae120157b58fb866da2305f80b86a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a1e0ae120157b58fb866da2305f80b86a">getXLength</a> ()</td></tr>
<tr class="memdesc:a1e0ae120157b58fb866da2305f80b86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter function for max x of the map  <a href="#a1e0ae120157b58fb866da2305f80b86a">More...</a><br /></td></tr>
<tr class="separator:a1e0ae120157b58fb866da2305f80b86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01279711baee1ba008b280e5ec291aec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a01279711baee1ba008b280e5ec291aec">getYLength</a> ()</td></tr>
<tr class="memdesc:a01279711baee1ba008b280e5ec291aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter function for Y length  <a href="#a01279711baee1ba008b280e5ec291aec">More...</a><br /></td></tr>
<tr class="separator:a01279711baee1ba008b280e5ec291aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac348e7631e5e8817283d1148c3170"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#af1ac348e7631e5e8817283d1148c3170">randomDirection</a> ()</td></tr>
<tr class="memdesc:af1ac348e7631e5e8817283d1148c3170"><td class="mdescLeft">&#160;</td><td class="mdescRight">to give random direction everytime we run this function in range of 1 to 4  <a href="#af1ac348e7631e5e8817283d1148c3170">More...</a><br /></td></tr>
<tr class="separator:af1ac348e7631e5e8817283d1148c3170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97938382e5e03ff5e3a6728bac85af86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a97938382e5e03ff5e3a6728bac85af86">updateLastSteps</a> (<a class="el" href="structNode.html">Node</a>)</td></tr>
<tr class="memdesc:a97938382e5e03ff5e3a6728bac85af86"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the last steps queue to maintain memory  <a href="#a97938382e5e03ff5e3a6728bac85af86">More...</a><br /></td></tr>
<tr class="separator:a97938382e5e03ff5e3a6728bac85af86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8b412bf2830bd5e8c0552579ee4ac7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a8d8b412bf2830bd5e8c0552579ee4ac7">checkLastNSteps</a> (<a class="el" href="structNode.html">Node</a>)</td></tr>
<tr class="memdesc:a8d8b412bf2830bd5e8c0552579ee4ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">To check if input node is in memory or not.  <a href="#a8d8b412bf2830bd5e8c0552579ee4ac7">More...</a><br /></td></tr>
<tr class="separator:a8d8b412bf2830bd5e8c0552579ee4ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9000b5fc9027440301639d7509c435"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a8a9000b5fc9027440301639d7509c435">checkLastNPositions</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a8a9000b5fc9027440301639d7509c435"><td class="mdescLeft">&#160;</td><td class="mdescRight">to check if robot visited these positions as stored in its memory  <a href="#a8a9000b5fc9027440301639d7509c435">More...</a><br /></td></tr>
<tr class="separator:a8a9000b5fc9027440301639d7509c435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5cf09de25f1532988f565af19ac390"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef5cf09de25f1532988f565af19ac390"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#aef5cf09de25f1532988f565af19ac390">printPath</a> ()</td></tr>
<tr class="memdesc:aef5cf09de25f1532988f565af19ac390"><td class="mdescLeft">&#160;</td><td class="mdescRight">to print the robot path if found <br /></td></tr>
<tr class="separator:aef5cf09de25f1532988f565af19ac390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8eed29ca324e01b4659a3c99b4e14d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a8c8eed29ca324e01b4659a3c99b4e14d">search</a> (std::vector&lt; std::vector&lt; int &gt;&gt;, std::pair&lt; int, int &gt;, std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a8c8eed29ca324e01b4659a3c99b4e14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">To search the path by randomly moving in map with constraint of not moving to node which is visited already in last N steps unless its the only choice robot has.  <a href="#a8c8eed29ca324e01b4659a3c99b4e14d">More...</a><br /></td></tr>
<tr class="separator:a8c8eed29ca324e01b4659a3c99b4e14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e06fe4a9140bd8114161e7c42a9b7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a85e06fe4a9140bd8114161e7c42a9b7d">setGoalNode</a> ()</td></tr>
<tr class="memdesc:a85e06fe4a9140bd8114161e7c42a9b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets goal <a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a> as per given value,location.  <a href="#a85e06fe4a9140bd8114161e7c42a9b7d">More...</a><br /></td></tr>
<tr class="separator:a85e06fe4a9140bd8114161e7c42a9b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb341442e9b2629873f6e8c220ea2846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#afb341442e9b2629873f6e8c220ea2846">setStartNode</a> ()</td></tr>
<tr class="memdesc:afb341442e9b2629873f6e8c220ea2846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Start <a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a> as per given value and location.  <a href="#afb341442e9b2629873f6e8c220ea2846">More...</a><br /></td></tr>
<tr class="separator:afb341442e9b2629873f6e8c220ea2846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33348010a426948b7f849bff67439e4e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a33348010a426948b7f849bff67439e4e">findNeighbors</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a33348010a426948b7f849bff67439e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find possible Neighbors around the node.  <a href="#a33348010a426948b7f849bff67439e4e">More...</a><br /></td></tr>
<tr class="separator:a33348010a426948b7f849bff67439e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529a590b4b69c8a25e26502251f4d244"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#a529a590b4b69c8a25e26502251f4d244">allNeighborsInMemory</a> (std::pair&lt; int, int &gt;)</td></tr>
<tr class="memdesc:a529a590b4b69c8a25e26502251f4d244"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHeck if the neighbors are in short memory of old steps taken.  <a href="#a529a590b4b69c8a25e26502251f4d244">More...</a><br /></td></tr>
<tr class="separator:a529a590b4b69c8a25e26502251f4d244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa743dd84e235919e8dd6c63c5c7eb1e8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRandomPlanner.html#aa743dd84e235919e8dd6c63c5c7eb1e8">getPath</a> ()</td></tr>
<tr class="memdesc:aa743dd84e235919e8dd6c63c5c7eb1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter function for found path  <a href="#aa743dd84e235919e8dd6c63c5c7eb1e8">More...</a><br /></td></tr>
<tr class="separator:aa743dd84e235919e8dd6c63c5c7eb1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The random planner tries to find a path to the goal by randomly moving in the environment (only orthogonal moves are legal). If the planner can not find an acceptable solution in less than max_step_number, the search should fail. The random planner, while being erratic, has a short memory, and it will never attempt to visit a cell that was visited in the last sqrt(max_step_number) steps except if this is the only available option. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a927c717d77534e0db8ee2401b8e8b0ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomPlanner::RandomPlanner </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>robot_pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>goal_pose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameterised constructor to take map, starting position and goal position of robot. </p>
<p>Parameterised constructor which initializes planner with input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::vector&lt;std::vector&gt;</td><td>world map </td></tr>
    <tr><td class="paramname">std::pair</td><td>starting position </td></tr>
    <tr><td class="paramname">std::pair</td><td>goal position</td></tr>
    <tr><td class="paramname">map</td><td></td></tr>
    <tr><td class="paramname">robot_pose</td><td>starting location of robot </td></tr>
    <tr><td class="paramname">goal</td><td>goal location of robot </td></tr>
  </table>
  </dd>
</dl>
<p>size of the map in y direction </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a529a590b4b69c8a25e26502251f4d244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RandomPlanner::allNeighborsInMemory </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CHeck if the neighbors are in short memory of old steps taken. </p>
<p>for checking if any of the neighbors are visited recently ornot</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair</td><td>position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any of the neighbor is in memory (lastNsteps)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any one of the neighbot was in memory ,else false </dd></dl>

</div>
</div>
<a class="anchor" id="a8a9000b5fc9027440301639d7509c435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RandomPlanner::checkLastNPositions </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>to check if robot visited these positions as stored in its memory </p>
<p>To check if the input position is visited recently or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair&lt;int,int&gt;</td><td>position of the robot</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>to check if position is visited</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if not visited, true if visited recently </dd></dl>

</div>
</div>
<a class="anchor" id="a8d8b412bf2830bd5e8c0552579ee4ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RandomPlanner::checkLastNSteps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a>&#160;</td>
          <td class="paramname"><em>toSearch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To check if input node is in memory or not. </p>
<p>Check if input node is visited already in recent steps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node is in memory</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toSearch</td><td><a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a> to searched</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if not visited else true i.,e visited recently </dd></dl>

</div>
</div>
<a class="anchor" id="a33348010a426948b7f849bff67439e4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, int &gt; &gt; RandomPlanner::findNeighbors </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find possible Neighbors around the node. </p>
<p>locate all neigtbors by moving in all directions and checking if they are not obstacles</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair</td><td>location of the</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of neighbors around the given input node location</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of all possible neighbors </dd></dl>

</div>
</div>
<a class="anchor" id="aa743dd84e235919e8dd6c63c5c7eb1e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;int, int&gt; &gt; RandomPlanner::getPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter function for found path </p>
<dl class="section return"><dt>Returns</dt><dd>vector of positions in path </dd></dl>

</div>
</div>
<a class="anchor" id="a1e0ae120157b58fb866da2305f80b86a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RandomPlanner::getXLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter function for max x of the map </p>
<dl class="section return"><dt>Returns</dt><dd>max horizontal length </dd></dl>

</div>
</div>
<a class="anchor" id="a01279711baee1ba008b280e5ec291aec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RandomPlanner::getYLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter function for Y length </p>
<dl class="section return"><dt>Returns</dt><dd>max depth of the map </dd></dl>

</div>
</div>
<a class="anchor" id="a2311066614013953f01b0658652e6b5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RandomPlanner::isObstacle </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>to_be_checked</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To check if robot is in defined boundary. </p>
<p>Checks if the position is valid positon in map and is obstacle or not 1 = obstacle, 0= free.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::pair</td><td>robot coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its blocked/obstacle, else false</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_be_checked</td><td>location to be checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool if its obstacle or free space </dd></dl>

</div>
</div>
<a class="anchor" id="a6ac0a6fdc7dd5c2c2576ace8f26d87f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNode.html">Node</a> RandomPlanner::moveDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a>&#160;</td>
          <td class="paramname"><em>someNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TO move in +y direction. </p>
<p>Move in respective direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a></td><td>node to be udpated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated <a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">someNode</td><td><a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a> to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated NOde </dd></dl>

</div>
</div>
<a class="anchor" id="a37871c2c07e26640fb0619db0299a3ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNode.html">Node</a> RandomPlanner::moveLeft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a>&#160;</td>
          <td class="paramname"><em>someNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TO move in left location. </p>
<p>Move in respective direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a></td><td>node to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated <a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">someNode</td><td>node to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated NOde </dd></dl>

</div>
</div>
<a class="anchor" id="af2b9b922d2d1b774dac4017024eda536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNode.html">Node</a> RandomPlanner::moveRight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a>&#160;</td>
          <td class="paramname"><em>someNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>to move in +x direction </p>
<p>Move in respective direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a></td><td>node to be updated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated node</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">someNode</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated NOde </dd></dl>

</div>
</div>
<a class="anchor" id="a9bc4c7235eea43f4c7ff7c1c55b81511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNode.html">Node</a> RandomPlanner::moveUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a>&#160;</td>
          <td class="paramname"><em>someNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>to Move in up direction, updates current node </p>
<p>Move in respective direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a></td><td>present node location</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Update <a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a> to move in upper block</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">someNode</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated NOde </dd></dl>

</div>
</div>
<a class="anchor" id="af1ac348e7631e5e8817283d1148c3170"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RandomPlanner::randomDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>to give random direction everytime we run this function in range of 1 to 4 </p>
<p>to produce random direction in 1-4 rangle denoting Directions 1 -&gt; Up 2 -&gt; Left 3 -&gt; DOwn 4 -&gt; Right</p>
<dl class="section return"><dt>Returns</dt><dd>random direction in range of {1,2,3,4}</dd>
<dd>
direction </dd></dl>

</div>
</div>
<a class="anchor" id="a8c8eed29ca324e01b4659a3c99b4e14d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, int &gt; &gt; RandomPlanner::search </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>robot_pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>goal_pose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To search the path by randomly moving in map with constraint of not moving to node which is visited already in last N steps unless its the only choice robot has. </p>
<p>Moves in random directions, can update the locaiton only if the robot can move in that direction and the new node is stored in queue unless its the only option forrobot to move.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::vector</td><td>world map </td></tr>
    <tr><td class="paramname">std::pair</td><td>start location </td></tr>
    <tr><td class="paramname">std::pair</td><td>goal location</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a85e06fe4a9140bd8114161e7c42a9b7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RandomPlanner::setGoalNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets goal <a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a> as per given value,location. </p>
<p>sets goal <a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a> from inputs of value(0=free) and location </p>

</div>
</div>
<a class="anchor" id="afb341442e9b2629873f6e8c220ea2846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RandomPlanner::setStartNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Start <a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a> as per given value and location. </p>
<p>sets start node from starting locaiton and value (0=free) </p>

</div>
</div>
<a class="anchor" id="a97938382e5e03ff5e3a6728bac85af86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RandomPlanner::updateLastSteps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNode.html">Node</a>&#160;</td>
          <td class="paramname"><em>a_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update the last steps queue to maintain memory </p>
<p>Update Last steps with new <a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a>, remove first in and add new element to planners short memory of length sqrt(max_step_number)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structNode.html" title="Basic Node Structure for each block. ">Node</a></td><td>location of new location to be updated in memory</td></tr>
    <tr><td class="paramname">a_node</td><td>new node to be included in memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/bob/Bob_old/Brain/DANDAMUDI-BHARGAV/include/<a class="el" href="RandomPlanner_8h_source.html">RandomPlanner.h</a></li>
<li>/home/bob/Bob_old/Brain/DANDAMUDI-BHARGAV/app/<a class="el" href="RandomPlanner_8cpp.html">RandomPlanner.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
